import os
os.environ['DISPLAY'] = ':0'  # to run the code from ssh but show on the monitor

import numpy as np 
import matplotlib.pyplot as plt
from scipy.signal import stft, butter, filtfilt, find_peaks
from scipy.fft import fft
from tkinter import ttk, filedialog, messagebox

# List of frequencies for horizontal lines
horizontal_lines_50cm = [6, 37.3, 106.1, 210.6, 315.2, 419.7, 524.3, 628.8, 733.4, 838, 942.5, 1047.1] ##50cm
horizontal_lines_40cm = [8,79, 57.5,163.2, 324.8, 476.5, 628.1, 779.8, 931.4, 1083.1, 1234.7, 1386.4] ##40cm
horizontal_lines_60cm = [4.1,26.1,74.1,146.6,219.1,291.6,364.1,436.6,509.1,581.6,654.1,726.6] ##60cm
horizontal_lines_30cm = [14.9,99.9,285.7,571.6,855.4,1149.3,1433.1,1716.9,1990.7,2264.6,2538.4,2812.3] ##30cm
horizontal_lines_linear = [10,20,30,40,50,60,70,80,90,100] ##vib generator
horizontal_lines = None
lines_dict = {'50': horizontal_lines_50cm, '40': horizontal_lines_40cm, '60': horizontal_lines_60cm, '30': horizontal_lines_30cm, 'linear': horizontal_lines_linear}


horizontal_lines=lines_dict['50cm']

    """
    Plots the Fast Fourier Transform (FFT) and Short-time Fourier Transform (STFT) of a given waveform.

    Parameters:
    timestamps (list): A list of timestamps corresponding to the waveform.
    waveform (list): The input waveform to be transformed.
    output_dir (str): The directory where the plot will be saved.
    freq (int, optional): The sampling frequency of the waveform. Defaults to 4000.
    ns (int, optional): The number of samples to use for the STFT. Defaults to 1024*2.
    smoothing (int, optional): The smoothing factor for the FFT. Defaults to 0.
    threshold (float, optional): The threshold for peak detection. Defaults to 0.005.

    Returns:
    None
    """
def plot_fft_stft(timestamps, waveform, output_dir, freq=4000, ns=1024*2, smoothing=0, threshold=0.005):
    # Find frequency from timestamps
    freq = int((len(timestamps)-2000)/ timestamps[-2001]) # find average sampling frequency
    
    print(freq)
    overlap = ns // 2

    # Calculate STFT
    f, t, Zxx = stft(waveform, freq, noverlap=overlap, nperseg=ns, window='hann', nfft=ns*2)

    # Calculate FFT
    n = len(waveform)
    f_fft = np.fft.fftfreq(n, d=1/freq)
    Y = fft(waveform)
    magnitude_spectrum = 2.0 / n * np.abs(Y[:n // 2])

    if smoothing > 0:
        smoothed_magnitude_spectrum = low_pass_filter(magnitude_spectrum, smoothing, freq)
    else:
        smoothed_magnitude_spectrum = magnitude_spectrum

    # Detect peaks with a threshold
    peaks, _ = find_peaks(smoothed_magnitude_spectrum, height=threshold)

    # Plot FFT and STFT in the same figure
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6), dpi=150, sharey=True, gridspec_kw={"width_ratios": [2, 1]})

    # Plot FFT
    ax2.plot(smoothed_magnitude_spectrum, f_fft[:n // 2], label=f'Smoothed FFT (smoothing={smoothing})' if smoothing > 0 else 'Normal FFT', color='blue', alpha=0.6)
    
    # Annotate all peaks
    if smoothing :
        for peak in peaks :
            peak_freq = f_fft[peak]
            ax2.annotate(f'{peak_freq:.2f} Hz', xy=(smoothed_magnitude_spectrum[peak], peak_freq),
                        xytext=(smoothed_magnitude_spectrum[peak]*0.8, peak_freq*1.05),
                        arrowprops=dict(facecolor='black', arrowstyle='->'))
            ax2.axhline(peak_freq, color='blue', linestyle='--', linewidth=0.7)

   # Add horizontal lines at specified frequencies
    for line_freq in horizontal_lines:
        ax2.axhline(line_freq, color='red', linestyle='-', linewidth=1.0)

    ax2.set_ylim((1, 500))
    ax2.set_xlim((0.0001, 0.5))
    ax2.set_yscale('log')
    ax2.set_title(f'{"Smoothed" if smoothing > 0 else "Normal"} FFT')
    ax2.set_xlabel('Magnitude')
    
    # Plot STFT
    ax1.pcolormesh(t, f, np.abs(Zxx), shading='auto', cmap='viridis')
    ax1.set_ylim((0, 500))
    ax1.set_yscale('log')  # Set y-axis to log scale
    ax1.set_title('Short-time FFT (STFT)')
    ax1.set_ylabel('Frequency [Hz]')
    ax1.set_xlabel('Time [sec]')

    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f'fft_stft_plot_smoothing_{smoothing}.png'))
    print(f"FFT and STFT plots saved in {output_dir}")
    plt.show()  # Show the plot

def low_pass_filter(data, cutoff_freq, fs, order=2):
    nyquist = 0.5 * fs
    normal_cutoff = cutoff_freq / nyquist
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    filtered_data = filtfilt(b, a, data)
    return filtered_data

def load_and_plot_numpy():
    # Define the output directory
    file_path = '/home/cslab/Desktop/Jul 22/Tests_before_8Aug/nothing/08-05_11-51-21_bare beam 50cm acc 5cm ID2cm/accelerometer_data.npy'  # Replace with your file dialog or fixed path
    file_path = '/home/cslab/Desktop/Jul 16 i2c scan/randomtests/08-09_12-34-28_bare beam40cm/accelerometer_data.npy'
    file_path = '/home/cslab/Desktop/Jul 16 i2c scan/08-12_11-05-14_adxl40cmbarebeamfr/accelerometer_data.npy'
    file_path = filedialog.askopenfilename(filetypes=[("Numpy files", "*.npy")])

    output_dir = os.path.dirname(file_path)
    os.makedirs(output_dir, exist_ok=True)

    if file_path:
        data = np.load(file_path)
        timestamps = data[0]
        z_data = data[1]

        fs = int(len(timestamps) / timestamps[-1])  # Sampling frequency
        cutoff_freq = 200  # Cutoff frequency for low-pass filter

        # Apply low-pass filter
        filtered_z_data = low_pass_filter(z_data, cutoff_freq, fs)

        # Save filtered data
        filtered_data_path = os.path.join(output_dir, 'filtered_accelerometer_data.npy')
        np.save(filtered_data_path, np.vstack((timestamps, filtered_z_data)))
        downsampledtimestamps, downsampled_z_data = reduce_noise(timestamps, z_data)
        
        # Plot with no smoothing
        plot_fft_stft(timestamps, z_data, output_dir, smoothing=0)
        
        # Plot with specified smoothing
        plot_fft_stft(timestamps, z_data, output_dir, smoothing=100)

def reduce_noise(timestamps, z_data):
    # Average every two datapoints to reduce noise
    z_data = z_data[::2]
    timestamps = timestamps[::2]
    return timestamps, z_data
    
load_and_plot_numpy()
